<!DOCTYPE html>
<html>
<head>
<title>Page Title</title>
</head>
<body>
<script setup>
//Assumptions: We will always engage. We will score for high, then mid, then low, but because we never will get to the low grid, we don't have to account for it
let balancingtime = [3, 5, 7];//it can take either 3 seconds, 5 seconds, or 7 seconds
let pointsforbalancing = [12, 10];//auton and teleop
let placetime = [2, 4];
let pointsforhigh = [6, 5];//auton and teleop
let pointsformid = [4, 3];
let autonpickup = [2, 4];
let autonmovepartofcycle = [4,6];
let movepartofcycle =  [7, 9, 11];
const autonPieceLimit = 5;
const pointsformobility = 3;
const scenariospoints=new Array(balancingtime.length).fill(new Array(placetime.length).fill(new Array(autonpickup.length).fill(new Array(autonmovepartofcycle.length).fill(new Array(movepartofcycle.length).fill(new Array(0))))));//for chart
const rnkValues=[];

//create a scenario tree
for (let i in balancingtime) {
    for (let j in placetime) {
        for (let k in autonpickup) {
            for (let l in autonmovepartofcycle) {
                for (let m in movepartofcycle) {
//initialize the variables
let nodesscored=0;
let autonPCCount = 0;
let holdingpiece=1;//start w/ holding one piece
    //auton
//auton balance
if(pointsforbalancing[0]!==0){//only auton balance if the game of the year allows auton balancing
    let points=pointsforbalancing[0]+pointsformobility;
    let time=150-balancingtime[i];
}
else{
    let points=pointsformobility;
    let time=150;
}
scenariospoints[i][j][k][l][m].push({x: 150-time, y: points});
//place pieces during auton
while (time - placetime[j] >= 135 && autonPCCount < autonPieceLimit) {
    points+=pointsforhigh[0]*holdingpiece;
    ++nodesscored;
	if (nodesscored % 3===0){points+=5;}
    time -= placetime[j];
	autonPCCount+=holdingpiece;
    holdingpiece = 0;
	scenariospoints[i][j][k][l][m].push({x: 150-time, y: points});
    if (time - autonmovepartofcycle[l]/2 - autonpickup[k] >= 135) {//the autonmovepartofcycle[l] is divided by two b/c the robot only travels to pick up the cones, not also back 
        time -= autonmovepartofcycle[l]/2 + autonpickup[k];
        ++holdingpiece;
        if(time-autonmovepartofcycle[l]/2-placetime[j]>=135){time-=autonmovepartofcycle[l]/2;}
        else{time=135;}
    }
}
    //endgame
if(pointsforbalancing[1]!==0){
    points+=pointsforbalancing[1];
    time=135-balancingtime[i];
}
else{time=135;}
scenariospoints[i][j][k][l][m].push({x: 150-time, y: points});
    //teleop
// if holding pieces at beginning of teleop
if (holdingpiece>0) {
    ++nodesscored;
    points+=pointsforhigh[1]*holdingpiece;
    holdingpiece = 0;
    time-= placetime[j];
    if (nodesscored % 3===0){points+=5;}//test for links
	scenariospoints[i][j][k][l][m].push({x: 150-time, y: points});
}
//score high and mid
while (time-movepartofcycle[l]-placetime[j]>=0) {
    ++nodesscored;
    time-=placetime[j]+movepartofcycle[l]+autonpickup[k];
    if(nodesscored<=9){points += pointsforhigh[1];}
    else{points+= pointsformid[1];}
    if (nodesscored % 3===0){points +=5;}
    scenariospoints[i][j][k][l][m].push({x: 150-time, y: points});
}
if (Math.floor(nodesscored / 3) > 3) {rnkValues.push({x:x,y:1})}
else{rnkValues.push({x:x,y:0})}
                }
            }
        }
    }
}
</script>

</body>
</html>