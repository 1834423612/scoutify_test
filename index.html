<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Strategy Charts</title>
</head>
<style>
    body {
        overflow: hidden;
    }

    h1 {
        width: 100%;
        text-align: center;
    }
    div {
        display: inline-block
    }

    canvas {
        max-width: 40vw
    }

    ul {
        list-style: none;
    }

    details {
        border: 1px solid #aaa;
        border-radius: 4px;
        padding: 0.5em 0.5em 0;
    }

    summary {
        font-weight: bold;
        margin: -0.5em -0.5em 0;
        padding: 0.5em;
    }

    details[open] {
        padding: 0.5em;
    }

    details[open] summary {
        border-bottom: 1px solid #aaa;
        margin-bottom: 0.5em;
    }

    #split-view-container {
        display: flex;
        flex-direction: row;
        justify-content: center;
        width: 100vw;
        height: 80vh;
        overflow: hidden;
        overflow-x:hidden;
    }

    #split-view-divider {
        width: 2px;
        height: 100%;
        background-color: #aaa;
        margin-left: 2vw;
        margin-right: 2vw;
    }

    .split-view {
        width: 47%;
        height: 80%;
    }

    .scroller {
        width: 100%;
        height: 100%;
        overflow-y: scroll;
    }
</style>

<body>
    <h1>Charts</h1>


    <div id="split-view-container">
        <div class="split-view">
            <h3>Strategy Comparison</h1>
            <details>
                <summary>Key:</summary>
                <ul>
                    <pre>
                        <li><mark style="background-color:rgb(0,255,0);">  </mark> : 2 RNKPNT (not tracking this every year)</li>
                        <li><mark style="background-color:rgb(255, 255, 0);">  </mark> : 1 RNKPNT</li>
                        <li><mark style="background-color:rgb(255,0,0);">  </mark> : 0 RNKPNT</li>
                    </pre>
                </ul>
            </details>
            <div class="scroller">
                    <div style="display:block;">
                        <canvas id="psChart"></canvas>
                        <canvas id="piecesscoredchart"></canvas> <!--Total Score-Scenario Chart-->
                        <p>Note that the color indicator for this graph is inaccurate b/c the points overlap. This year
                            it's ok b/c
                            the rnkpnt is given to for getting a y-value greater than a certain number</p>
                        <canvas id="scenarioChart"></canvas> <!--Pieces vs Total Score-->
                        <canvas id="rnkpntChart"></canvas> <!--Ranking points vs Scenario id-->
                    </div>
            </div>
        </div>
        <div id="split-view-divider"></div>
        <div class="split-view">
            <h3>Selected Scenario</h3>
            <div class="scroller">
                <p id="tooltip"></p>
                <div style="display:block">
                    <canvas id="psotchart"></canvas>
                    <p>Note: always balances at 15s but not necessarily at the end</p>
                    <canvas id="myChart"></canvas>
                    <p id="scenarioaction">hello</p>
                </div>
            </div>
        </div>
    </div>



    <script type="module" src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>
    <script type="text/javascript" src="http://code.jquery.com/jquery.min.js"></script>
    <script>
        //add functions when relevant or needed
        //update other years using this updated code
        //add compatability for multiple game pieces at a time with the new const holdPieceLimit
        //add compatability for rnkpnts
        //need to add in table that give data about selceted variable
        //there is a glitch where the tooltip dissapears occasionally
        //The only rnkpnts that are possible to track are the ones achieved through scoring a number of game pieces in a certain way. All the other ones involve teamates doing good.

        //Assumptions: We will always engage. We will score for high, then mid, then low, but because we never will get to the low grid, we don't have to account for it

        //to read json:
        /*
            $.getJSON('names.json',function(data){
                globalData = data
            })
        */
        //intitialize variable
        //There are two common types of arrays: points and time. Whenever there is a points array, it will look like this: [pointsAwardedForScoringThisWayInAuton,pointsAwardedForScoringThisWayInTeleop]. Whenever there is a time array, it will look like this [guess#1forHowLongThisTaskWillTake,...other guesses]. The guesses must be arranged in order from least to greatest time and can contain no more than 10 guesses. The grabamount array is like the time arrays in that it must be arranged the same way and can't be longer than 10 values. It will look like this: [1stguessForAveragePiecesGrabbedWhileTryingToPickup,other guesses]
        const dolinkshappeninthisgame = true;
        const linkthresholdprogression = [];//leave this empty unless the links[1] is changing (links[1] is in the for-loop and represents how many pieces makes a link) like in the game steamworks
        //for the steamship game, const linkthresholdprogression=[1,2,3,4,5];
        //for any of the following time arrays and the grabamount array, the first index must have the smallest value, and the last index must have the largest value
        const balancingtime = [3, 5, 7];//it can take either 3 seconds, 5 seconds, or 7 seconds. this includes the time it takes to get to the balancing area.
        const pointsforbalancing = [12, 10];//auton and teleop
        const placetime = [2, 4];
        const pointsforbestscorer = [6, 5];// high nodes: auton and teleop. the computer will do the pointsforbestscorer until it reaches the limit, and then switches to scoring w/ pointsforokscorer
        const limitforbestscorer = 9;
        const pointsforokscorer = [4, 3];//mid nodes
        const pickuptime = [2, 4];
        const autonmovepartofcycle = [4, 6];
        const movepartofcycle = [7, 9, 11];//if the game is pick & place and the goals take different times to travel to, estimate the average travel time
        const autonPieceLimit = 5;
        const pointsformobility = 3;
        const grabamount = [1];//for games where you can grab more than one piece, this is the estimated average pieces grabbed. this must be a whole number
        const holdPieceLimit = 1;
        const piecesscoredforrnkpnt = [4 * 3, 0];//assuming coop; must set this to 0 or Infinity in games where this doesn't exist
        //for charts
        const scenariospoints = [];//looks like this: [{x:time,y:points},...] & this contains multiple coordinate pairs for each scenario
        const piecesscoredovertime = [];//like the scenariospoints array except the y-values track the pieces scored instead
        const rnkValues = [];//looks like this: [{x:1stScenarioInTheScenarioTree,y: #ofRnkPnts from links},...{x:lastScenarioInTheScenarioTree,y: #ofRnkPnts from links}] 
        const piecesoverscenarios = [];//like rnkValues except the y-properties show pieces scored
        const totalscores = [];//like rnkValues except the y-properties show the totalscores
        const allinclusivescenariodata = [];//like rnkValues except the y-properties are pieces scored and the x-properties show the totalscores
        const color = [];//looks like this: ["rgb(color for 1stScenarioInTheScenarioTree)",..."rgb(color for lastScenarioInTheScenarioTree)"] 
        const xyValues = [];//this is for a single scenario & looks like this: [{x:score,y:time},...]
        const psotValues = [];//looks like xyValues except x-property is pieces scored
        const scenarioaction = [];
        //make a scenario to be represented by two data types, a string and integer
        //this needs to be done b/c the chart can't use a string for numbers on an axis & the human has no idea what the number is
        //define some scenario related variables
        const allthelengthsbesidesbalance = placetime.length * pickuptime.length * autonmovepartofcycle.length * movepartofcycle.length * grabamount.length;
        const allthelengthsbesidesbalanceandplace = pickuptime.length * autonmovepartofcycle.length * movepartofcycle.length * grabamount.length;
        const allthelengthsbesidesbalanceandplaceandpickup = autonmovepartofcycle.length * movepartofcycle.length * grabamount.length;
        const lengthsofmovepartofcycleandgrabamount = movepartofcycle.length * grabamount.length;
        //turn a string that represents the indices in the scenario tree below into a number
        const encodescenario = (a) =>
            a.charAt(0) * allthelengthsbesidesbalance +
            a.charAt(1) * allthelengthsbesidesbalanceandplace +
            a.charAt(2) * allthelengthsbesidesbalanceandplaceandpickup +
            a.charAt(3) * lengthsofmovepartofcycleandgrabamount +
            a.charAt(4) * grabamount.length +
            a.charAt(5) * 1//the multiplication by one switches the type from string to number so that the a.charAt(4) is added instead of concatenated
            ;
        //the following function undoes the encodescenario function by converting a scenario from the number format into the string format
        const decodescenario = (a) =>
            "" +
            Math.floor(a / allthelengthsbesidesbalance) +
            Math.floor(a % allthelengthsbesidesbalance / allthelengthsbesidesbalanceandplace) +
            Math.floor(a % allthelengthsbesidesbalance % allthelengthsbesidesbalanceandplace / allthelengthsbesidesbalanceandplaceandpickup) +
            Math.floor(a % allthelengthsbesidesbalance % allthelengthsbesidesbalanceandplace % allthelengthsbesidesbalanceandplaceandpickup / lengthsofmovepartofcycleandgrabamount) +
            Math.floor(a % allthelengthsbesidesbalance % allthelengthsbesidesbalanceandplace % allthelengthsbesidesbalanceandplaceandpickup % lengthsofmovepartofcycleandgrabamount / grabamount.length) +
            a % allthelengthsbesidesbalance % allthelengthsbesidesbalanceandplace % allthelengthsbesidesbalanceandplaceandpickup % lengthsofmovepartofcycleandgrabamount % grabamount.length
            ;


        //create a scenario tree, but start by defining variables to use during the iterations
        const scenario = { points: 0, time: 150 };
        let piecesscored = [], holdingpiece = [], links = [];
        for (let i in balancingtime) {
            for (let j in placetime) {
                for (let k in pickuptime) {
                    for (let l in autonmovepartofcycle) {
                        for (let m in movepartofcycle) {
                            for (let n in grabamount) {
                                //this loops through each scenario where the scenario is defined in string format as (""+i+j+k+l+m+n) 
                                //initialize the variables
                                links = [dolinkshappeninthisgame, 3, 5, 5, 0];//first value is to see if links exist, the second value is how many pieces one needs for a link, and the 3rd value is the points for getting a link during auton and the 4th value is the points during teleop; for the steamship game, the gears should should be the bestscoring method that makes 0 points, but this array will be [true,1,60,40], and whenever we get the threshold the game, we will have to update the second value
                                //links has a fith value set to 0 to keep track of what threshold the bot is up to
                                piecesscored[0] = 0;
                                holdingpiece[0] = 1;//start w/ holding one piece
                                //holdingpiece[0]=1;//for a 2nd game piece
                                scenario.time = 150; //seconds left in the game
                                scenario.points = pointsformobility;//will always strive to make a robot that can get the mobility points
                                //auton
                                //if(!startpreloaded){time-pickuptime[k]}
                                //if(!startneargoal){time-autonmovepartofcycle[l]} this is unimplemented yet

                                //if there's time to balance and score...
                                if (scenario.time - placetime[j] - balancingtime[i] * (pointsforbalancing[0] > 0) >= 135) {
                                    //place pieces during auton
                                    while (scenario.time - placetime[j] - balancingtime[i] * (pointsforbalancing[0] > 0) >= 135 && piecesscored[0] < autonPieceLimit) {
                                        scorepiece(0, i, j, k, l, m, n);
                                        if (scenario.time - autonmovepartofcycle[l] / 2 - pickuptime[k] >= 135) {//the autonmovepartofcycle[l] is divided by two b/c the bot only travels to pick up game pices, not also back 
                                            scenario.time -= autonmovepartofcycle[l] / 2 + pickuptime[k];
                                            holdingpiece[0] += grabamount[n];
                                            if (piecesscored[0] + holdingpiece[0] > autonPieceLimit) { holdingpiece[0] = autonPieceLimit - piecesscored[0] }//prevents holding more pieces than allowed given the autonPieceLimit and the pieces already scored: this is needed in a game where you can pick up more than one piece at a time
                                            if (scenario.time - autonmovepartofcycle[l] / 2 - placetime[j] - balancingtime[i] * (pointsforbalancing[0] > 0) >= 135) { scenario.time -= autonmovepartofcycle[l] / 2; }
                                            else if (pointsforbalancing[0] > 0) {//balance if auton-balance is allowed
                                                scenario.time = 135 + balancingtime[i] * (pointsforbalancing[0] > 0);
                                                balance(0, i,j,k,l,m,n);
                                            }
                                            else { scenario.time = 135; }
                                        }
                                    }
                                }
                                else if (pointsforbalancing[0] > 0) { balance(0, i,j,k,l,m,n); }//balance if auton-balance is allowed
                                //teleop
                                scenario.time = 135;
                                scenarioaction[encodescenario(""+i+j+k+l+m+n)].push(" teleop: ");
                                // if holding pieces at beginning of teleop
                                if (holdingpiece[0] > 0) { scorepiece(1,i, j, k,l, m,n, 1); }//this doesn't count the time it takes to go from the charge station into the grid, which is bad for games when the place where mobility points are awarded is far away from a goal
                                //score high and mid
                                while (scenario.time - pickuptime[k] - movepartofcycle[m] - placetime[j] - balancingtime[i] * (pointsforbalancing[1] > 0) >= 0) {//if we want the program to see how much slower we can be w/out worsening score changing the 0 in ">=0" to some other number is a start.
                                    holdingpiece[0] += grabamount[n];
                                    scorepiece(1,i, j, k,l, m,n,);
                                }
                                //endgame
                                if (pointsforbalancing[1] > 0) { balance(1, i,j,k,l,m,n); }
                                //push chart values that have scenarios as a dimension
                                const x = encodescenario('' + i + j + k + l + m + n);
                                if (piecesscored[0] >= piecesscoredforrnkpnt[0] && piecesscoredforrnkpnt[0] && piecesscored[1] >= piecesscoredforrnkpnt[1] && piecesscoredforrnkpnt[1]) {
                                    rnkValues.push({ x: x, y: 2 });
                                    color.push("rgb(0,255,0)");
                                }
                                else if ((piecesscored[0] >= piecesscoredforrnkpnt[0] && piecesscoredforrnkpnt[0]) || (piecesscored[1] >= piecesscoredforrnkpnt[1] && piecesscoredforrnkpnt[1])) {
                                    rnkValues.push({ x: x, y: 1 });
                                    color.push("rgb(255,255,0)");
                                }
                                else {
                                    rnkValues.push({ x: x, y: 0 });
                                    color.push("rgb(255,0,0)");
                                }
                                totalscores.push({ x: x, y: scenario.points });
                                piecesoverscenarios.push({ x: x, y: piecesscored[0] });
                                allinclusivescenariodata.push({ x: scenario.points, y: piecesscored[0], scenario: x })
                            }
                        }
                    }
                }
            }
        }


        //Figure out which scenario each set of scatter points belongs to by defining the endpoints of each scenaraio i.e. where one scenario stops and a new one starts.
        //To define where the endpoints will appear, loop through each value in the scenariospoints, which holds coordinate points for everytime the bot scores points for each scenario.
        //When the points-value (aka y-property) of one coordinate pair is less than the points of another coordinate pair, there must be a new scenario.
        const endpoints = [-1];//its -1 b/c it's the ending-point in a scenario where nothing happens: it was done like this so the next scenario starts w/ zero (-1+1=0). I added one b/c the endpoint of one scenario is 1 plus the startpoint of another scenario.
        for (let i = 0; i < scenariospoints.length - 1; i++) {
            if (scenariospoints[i].x > scenariospoints[i + 1].x) { endpoints.push(i); }
        }
        endpoints.push(scenariospoints.length);
        //do the same for the pieces scored-time chart
        const endpointsofpsotValues = [-1];
        for (let i = 0; i < piecesscoredovertime.length - 1; i++) {
            if (piecesscoredovertime[i].x > piecesscoredovertime[i + 1].x) { endpointsofpsotValues.push(i); }
        }
        endpointsofpsotValues.push(piecesscoredovertime.length);


        //create data arrays that will be used for the all inclusive chart's tooltip
        const groupsofpoints = [];
        const coordinatesofgroups = [];
        for (let i in allinclusivescenariodata) {
            const coordinates = allinclusivescenariodata[i].x + ";" + allinclusivescenariodata[i].y;
            //If the coordinates already exists in coordinatesofgroups, then just need to add these coordinates to the list. Otherwise, need to create the said array before pushing it into the array.
            if (coordinatesofgroups.includes(coordinates)) { groupsofpoints[coordinatesofgroups.indexOf(coordinates)].push(decodescenario(i)); }
            else {
                groupsofpoints.push([decodescenario(i)]);
                coordinatesofgroups.push(coordinates);
            }
        }
        const zeroindices = [];
        for (let i of groupsofpoints) { zeroindices.push(i[0]); }


        //load charts
        updatedata(0);
        window.addEventListener("load", function (event) { //only initialize chart once window loads completely to avoid context issues
            const scenariochart = new Chart("scenarioChart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: color,
                        data: allinclusivescenariodata
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'Pieces Scored - Total Score'
                    },
                    tooltips: {
                        bodyFontStyle: "bold",
                        footerFontStyle: "normal",
                        callbacks: {
                            label: function (tooltipItem, data) {
                                //if this is the first point in a group, than activate all the details for that group
                                const scenario = decodescenario(tooltipItem.index);
                                if (zeroindices.includes(scenario)) {
                                    document.getElementById("tooltip").innerHTML = "";
                                    for (let i of groupsofpoints[zeroindices.indexOf(scenario)]) {
                                        const detail = document.createElement("details");
                                        document.getElementById("tooltip").appendChild(detail);
                                        detail.innerHTML = "<summary>" + i + "</summary>" +
                                            "Balance (s): " + balancingtime[i.charAt(0)] + "<br>" +
                                            "Place (s): " + placetime[i.charAt(1)] + "<br>" +
                                            "Pickup (s): " + pickuptime[i.charAt(2)] + "<br>" +
                                            "Autonmovepartofcycle (s): " + autonmovepartofcycle[i.charAt(3)] + "<br>" +
                                            "Movepartofcycle (s): " + movepartofcycle[i.charAt(4)] + "<br>" +
                                            "Grabamount (pieces on average): " + grabamount[i.charAt(5)]
                                            ;
                                    }
                                }
                            },
                            //When points overlap, can only have one footer, but multiple labels.
                            footer: function (tooltipItems, data) {
                                return [
                                    "Total Score: " + allinclusivescenariodata[tooltipItems[0].index].x,
                                    "Pieces Scored: " + allinclusivescenariodata[tooltipItems[0].index].y
                                ];
                            }
                        }
                    },
                    onClick: function (evt) {
                        var element = scenariochart.getElementAtEvent(evt);
                        if (element.length > 0) {
                            var ind = element[0]._index;
                            if (confirm('Do you want to see this scenario?')) {
                                updatedata(ind);
                                psotchart.update();
                                scoretimechart.update();
                            }
                        }
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Total Score",
                            },
                            ticks: {
                                min: allinclusivescenariodata[allinclusivescenariodata.length - 1].x,
                                max: allinclusivescenariodata[0].x,
                            }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Pieces Scored",
                            },
                            ticks: {
                                min: allinclusivescenariodata[allinclusivescenariodata.length - 1].y,
                                max: allinclusivescenariodata[0].y,
                            }
                        }],
                    }
                }
            });
            const rnkpntchart = new Chart("rnkpntChart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: color,
                        data: rnkValues
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'RANK POINTS FROM LINKS - SCENARIO'
                    },
                    tooltips: {
                        bodyFontStyle: "bold",
                        footerFontStyle: "normal",
                        callbacks: {
                            label: function (tooltipItem, data) {
                                if (rnkValues[tooltipItem.index].y === 0) { return "0"; }//there was a bug where if it was 0, then nothing it wouldn't show this
                                return rnkValues[tooltipItem.index].y;
                            },
                            //color does not appear before the footer
                            footer: function (tooltipItems, data) {
                                return [
                                    "Balance (s): " + balancingtime[decodescenario(tooltipItems[0].index).charAt(0)],
                                    "Place (s): " + placetime[decodescenario(tooltipItems[0].index).charAt(1)],
                                    "Pickup (s): " + pickuptime[decodescenario(tooltipItems[0].index).charAt(2)],
                                    "Autonmovepartofcycle (s): " + autonmovepartofcycle[decodescenario(tooltipItems[0].index).charAt(3)],
                                    "Movepartofcycle (s): " + movepartofcycle[decodescenario(tooltipItems[0].index).charAt(4)],
                                    "Grabamount (pieces on average): " + grabamount[decodescenario(tooltipItems[0].index).charAt(5)]
                                ];
                            }
                        }
                    },
                    onClick: function (evt) {
                        var element = rnkpntchart.getElementAtEvent(evt);
                        if (element.length > 0) {
                            var ind = element[0]._index;
                            if (confirm('Do you want to see this scenario?')) {
                                updatedata(ind);
                                psotchart.update();
                                scoretimechart.update();
                            }
                        }
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Scenarios Encoded",
                            },
                            ticks: { min: 0, max: balancingtime.length * allthelengthsbesidesbalance - 1 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Rank Points From Links",
                            },
                            ticks: { min: 0, max: rnkValues[0].y, stepSize: 1 }
                        }],
                    }
                }
            });
            const pschart = new Chart("psChart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: color,
                        data: totalscores
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'TOTAL SCORE - SCENARIO'
                    },
                    tooltips: {
                        bodyFontStyle: "bold",
                        footerFontStyle: "normal",
                        callbacks: {
                            label: function (tooltipItem, data) {
                                return totalscores[tooltipItem.index].y;
                            },
                            //color does not appear before the footer
                            footer: function (tooltipItems, data) {
                                return [
                                    "Balance (s): " + balancingtime[decodescenario(tooltipItems[0].index).charAt(0)],
                                    "Place (s): " + placetime[decodescenario(tooltipItems[0].index).charAt(1)],
                                    "Pickup (s): " + pickuptime[decodescenario(tooltipItems[0].index).charAt(2)],
                                    "Autonmovepartofcycle (s): " + autonmovepartofcycle[decodescenario(tooltipItems[0].index).charAt(3)],
                                    "Movepartofcycle (s): " + movepartofcycle[decodescenario(tooltipItems[0].index).charAt(4)],
                                    "Grabamount (pieces on average): " + grabamount[decodescenario(tooltipItems[0].index).charAt(5)]
                                ];
                            }

                        }
                    },
                    onClick: function (evt) {
                        var element = pschart.getElementAtEvent(evt);
                        if (element.length > 0) {
                            var ind = element[0]._index;
                            if (confirm('Do you want to see this scenario?')) {
                                updatedata(ind);
                                psotchart.update();
                                scoretimechart.update();
                            }
                        }
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Scenarios Encoded",
                            },
                            ticks: { min: 0, max: balancingtime.length * allthelengthsbesidesbalance - 1 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Total Score",
                            },
                            ticks: { min: totalscores[totalscores.length - 1].y, max: totalscores[0].y }
                        }],
                    }
                }
            });
            const piecesschart = new Chart("piecesscoredchart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: color,
                        data: piecesoverscenarios
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'PIECES SCORED - SCENARIO'
                    },
                    tooltips: {
                        bodyFontStyle: "bold",
                        footerFontStyle: "normal",
                        callbacks: {
                            label: function (tooltipItem, data) {
                                return piecesoverscenarios[tooltipItem.index].y;
                            },
                            //color does not appear before the footer
                            footer: function (tooltipItems, data) {
                                return [
                                    "Balance (s): " + balancingtime[decodescenario(tooltipItems[0].index).charAt(0)],
                                    "Place (s): " + placetime[decodescenario(tooltipItems[0].index).charAt(1)],
                                    "Pickup (s): " + pickuptime[decodescenario(tooltipItems[0].index).charAt(2)],
                                    "Autonmovepartofcycle (s): " + autonmovepartofcycle[decodescenario(tooltipItems[0].index).charAt(3)],
                                    "Movepartofcycle (s): " + movepartofcycle[decodescenario(tooltipItems[0].index).charAt(4)],
                                    "Grabamount (pieces on average): " + grabamount[decodescenario(tooltipItems[0].index).charAt(5)]
                                ];
                            }

                        }
                    },
                    onClick: function (evt) {
                        var element = piecesschart.getElementAtEvent(evt);
                        if (element.length > 0) {
                            var ind = element[0]._index;
                            if (confirm('Do you want to see this scenario?')) {
                                updatedata(ind);
                                psotchart.update();
                                scoretimechart.update();
                            }
                        }
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Scenarios Encoded",
                            },
                            ticks: { min: 0, max: balancingtime.length * allthelengthsbesidesbalance - 1 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Pieces Scored",
                            },
                            ticks: { min: piecesoverscenarios[piecesoverscenarios.length - 1].y, max: piecesoverscenarios[0].y }
                        }],
                    }
                }
            });

            const psotchart = new Chart("psotchart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: "rgb(0,0,255)",
                        data: psotValues
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'PIECES SCORED - TIME'
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Time",
                            },
                            ticks: { min: 0, max: 150 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Pieces Scored",
                            },
                            ticks: { min: 0, max: piecesoverscenarios[0].y },
                        }],
                    }
                }
            });
            const scoretimechart = new Chart("myChart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: "rgb(0,0,255)",
                        data: xyValues
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'SCORE - TIME'
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Time",
                            },
                            ticks: { min: 0, max: 150 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Score",
                            },
                            ticks: { min: 0, max: totalscores[0].y }
                        }],
                    }
                }
            });
        });
        function updatedata(scenario) {
            let scenarioencoded = scenario;
            if (typeof (scenario) === "string") { scenarioencoded = encodescenario(scenario); }//this will allow the "arg: scenario" to be entered in string format or integer format
            const startpoint = endpoints[scenarioencoded] + 1;//an accessor
            const endpoint = endpoints[scenarioencoded + 1];
            const startpointofpsotValues = endpointsofpsotValues[scenarioencoded] + 1;//an accessor
            const endpointofpsotValues = endpointsofpsotValues[scenarioencoded + 1];
            //empty out the data arrays
            xyValues.splice(0, xyValues.length);
            psotValues.splice(0, psotValues.length);
            //for each point in the given range, push a point to the xyValues array
            for (let i = startpoint; i < endpoint + 1; i++) { xyValues.push(scenariospoints[i]); }
            for (let i = startpointofpsotValues; i < endpointofpsotValues + 1; i++) { psotValues.push(piecesscoredovertime[i]); }
        }
        function checkforlinks(ifauton0ifteleop1) {
            if (links[0] && piecesscored[0] % links[1] === 0) {
                scenario.points += links[2 + ifauton0ifteleop1];
                if (linkthresholdprogression.length > 0) {
                    ++links[4];
                    links[1] = linkthresholdprogression[links[4]];
                }
            }
        }
        function scorepiece(ifauton0ifteleop1,i, j, k,l, m,n, holdingpiecesatbeginningofteleop) {
            piecesscored[0] += holdingpiece[0];
            if (holdingpiecesatbeginningofteleop === 1 || ifauton0ifteleop1 === 0) { scenario.time -= placetime[j]; }
            else { scenario.time -= placetime[j] + movepartofcycle[m] + pickuptime[k]; }
            if (piecesscored[0] <= limitforbestscorer) { scenario.points += pointsforbestscorer[ifauton0ifteleop1] * holdingpiece[0]; }
            else { scenario.points += pointsforokscorer[ifauton0ifteleop1] * holdingpiece[0]; }
            holdingpiece[0] = 0;
            checkforlinks(ifauton0ifteleop1);
            scenariospoints.push({ x: 150 - scenario.time, y: scenario.points });
            piecesscoredovertime.push({ x: 150 - scenario.time, y: piecesscored[0] });
            scenarioaction[encodescenario(""+i+j+k+l+m)].push(" scoredpiece; ");
        }
        function balance(ifauton0ifteleop1, i,j,k,l,m,n) {
            scenario.points += pointsforbalancing[ifauton0ifteleop1];
            scenario.time -= balancingtime[i];
            scenariospoints.push({ x: 150 - scenario.time, y: scenario.points });
            scenarioaction[encodescenario(""+i+j+k+l+m+n)].push(" balanced; ");
        }
    </script>

</body>

</html>
