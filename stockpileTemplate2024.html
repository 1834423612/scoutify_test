<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Strategy Charts</title>
</head>
<style>
    body {
        overflow: hidden;
    }

    h1 {
        width: 100%;
        text-align: center;
    }

    div {
        display: inline-block
    }

    canvas {
        max-width: 40vw
    }

    ul {
        list-style: none;
    }

    details {
        border: 1px solid #aaa;
        border-radius: 4px;
        padding: 0.5em 0.5em 0;
    }

    summary {
        font-weight: bold;
        margin: -0.5em -0.5em 0;
        padding: 0.5em;
    }

    details[open] {
        padding: 0.5em;
    }

    details[open] summary {
        border-bottom: 1px solid #aaa;
        margin-bottom: 0.5em;
    }

    #split-view-container {
        display: flex;
        flex-direction: row;
        justify-content: center;
        width: 100vw;
        height: 80vh;
        overflow: hidden;
        overflow-x: hidden;
    }

    #split-view-divider {
        width: 2px;
        height: 100%;
        background-color: #aaa;
        margin-left: 2vw;
        margin-right: 2vw;
    }

    .split-view {
        width: 47%;
        height: 80%;
    }

    .scroller {
        width: 100%;
        height: 100%;
        overflow-y: scroll;
    }

    td {
        border: 1px solid black;
    }

    td:first-child {
        background-color: yellow;
    }
</style>

<body>
    <h1>Charts</h1>
    <details open>
        <summary>UI: (click to open and close)</summary>
        <div id="ui"></div>
    </details>
    <div id="split-view-container">
        <div class="split-view">
            <h3>Strategy Comparison</h1>
                <details>
                    <summary>Key:</summary>
                    <ul>
                        <pre>
                        <li><mark style="background-color:rgb(0,255,0);">  </mark> : 2 RNKPNT (not tracking this every year)</li>
                        <li><mark style="background-color:rgb(255, 255, 0);">  </mark> : 1 RNKPNT</li>
                        <li><mark style="background-color:rgb(255,0,0);">  </mark> : 0 RNKPNT</li>
                    </pre>
                    </ul>
                </details>
                <div class="scroller">
                    <div style="display:block;">
                        <canvas id="psChart"></canvas>
                        <canvas id="piecesScoredchart"></canvas> <!--Total Score-Scenario Chart-->
                        <p>Note that the color indicator for this graph is inaccurate b/c the points overlap.
                            <canvas id="scenarioChart"></canvas> <!--Pieces vs Total Score-->
                        <p id="shiftkey"></p>
                        <canvas id="rnkpntChart"></canvas> <!--Ranking points vs Scenario id-->
                    </div>
                </div>
        </div>
        <div id="split-view-divider"></div>
        <div class="split-view">
            <h3>Selected Scenario</h3>
            <div class="scroller">
                <p id="tooltip"></p>
                <div style="display:block">
                    <canvas id="psotchart"></canvas>
                    <canvas id="myChart"></canvas>
                    <table id="table_id">
                        <tr id="tr0">
                            <td>Time Left</td>
                        </tr>
                        <tr id="tr1">
                            <td>Elapsed Time</td>
                        </tr>
                        <tr id="tr2">
                            <td>Event</td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>
    </div>
    <script type="module" src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>
    <!--<script type="text/javascript" src="http://code.jquery.com/jquery.min.js"></script>-->
    <script>
        //working on:

        //add scenario data on specific scenario side
        //add back in links like 2023 file

        //for more than 10 scenarios, need to convert to two digit identification
        //program lacks the fact that there will be game pieces in the center of the field that are closer at the begginging of teleop
        //automated intervals can be a function
        //add score into table
        //add in the shift select function
        //whenever everything is zero rnkpoints, for some reason, the rnkpoint chart doesn't display
        //program lacks the fact that there will be game pieces in the center of the field that are closer at the begginging of teleop

        //auton links not implemented
        const doLinksExist = false;
        const linkProgression = [3,3,3,3,3,3,3,3,3,3,3,3];//represents how many pieces makes a link, next number in a array is how many pieces constitutes the 2nd link, and so on and so forth: like in the game steamworks
        //for the steamship game, linkProgression=[1,2,3,4,5];
        //points arrays are structured as [points for auton, points for teleop]
        const linkPoints = [5, 5]
        const pointsForBalancing = [0, 3];
        const pointsForBestScorer = [5, 2];//speaker
        const pointsForOkScorer = [2, 1];//amp
        const pointsForTrap = [5, 5];
        const pointsForMobility = 2;
        const autonPieceLimit = 1;
        const holdPieceLimit = 1;
        //structure of piecesScoredForRnkPnt: [# of piecesScored[0] for RnkPnt,# of piecesScored[1] for RnkPnt]
        const piecesScoredForRnkPnt = [15, 0];//assuming coop; can set to 0 in games this doesn't exist
        let iteratingArrays = [
            ["Balance (s)",5,6,7,8],
            ["Output (s)",1.5,2,2.5,3],
            ["Intake (s)",.75,1,1.25,1.5],
            ["Auton Movement (s)",2,3,3.5,4],//all the movement times include aligning
            ["Teleop Movement (s)",7.5, 10, 11, 12],
            ["Stockpile Movement Fraction",1/2],
            ["Grab Amount (on average)",1],
        ];
        let numberOfScenarios = 1
        for (let i of iteratingArrays) { numberOfScenarios *= i.length - 1 }
        const game = {
            allPointsVsTime: [], allPieceCountVsTime : [], rnkValueVsScenario : [], pieceCountVsScenario : [], totalScoreVsScenario : [], pieceCountVsTotalScore : [], specificPointsVsTime : [], specificPieceCountVsTime : [], color: [],
            scenarioAction: [], scenarioTimes: [], pointsClicked: [], zeroIndicesPointsClicked: [],
//            numberOfScenarios: [],
            //piecesScored: [], holdingPiece: [], links: []
        }

        //numberOfScenarios = game.numberOfScenarios

        const ui = document.getElementById("ui")

        for(let i in iteratingArrays){
            ui.innerHTML += iteratingArrays[i][0] + ": "
            const input = document.createElement("input")
            input.id="ui"+i
            ui.appendChild(input)
            ui.appendChild(document.createElement("br"))
        }
        for(let i in iteratingArrays){
            document.getElementById("ui"+i).value=iteratingArrays[i].slice(1)
        }
        
        const recalculate = document.createElement("button")
        recalculate.textContent="Recalculate"
        ui.appendChild(recalculate)
        
        recalculate.onclick = calculate()
        calculate()

        //turn a string that represents the indices in the scenario tree below into a number
        function encodeScenario(a) {
            let result = 0;
            let multiplier = 1;
            for (let i = a.length - 1; i >= 0; --i) {
                result += a.charAt(i) * multiplier
                multiplier *= iteratingArrays[i].length - 1
            }
            return result;
        }
        //undo the encodeScenario function by converting a scenario from the number format into the string format
        function decodeScenario(a) {
            let divisor = numberOfScenarios / (iteratingArrays[0].length - 1)
            let result = ""
            let remainder = a
            for (let i in iteratingArrays) {
                result += Math.floor(remainder / divisor);
                remainder -= Math.floor(remainder / divisor) * divisor;
                if (iteratingArrays[Number(i) + 1]) divisor /= iteratingArrays[Number(i) + 1].length - 1;
            }
            return result
        }

        function updatedata(scenario) {
            for (let i in scenarioTimes) {
                if (scenarioTimes[i].includes("-")) {
                    document.write("problem: a scenario takes longer than 2:30");
                    scenarioAction[i]-=0
                }
            }
            let scenarioDecoded = scenario;
            if (typeof (scenario) === "string") { scenarioDecoded = encodeScenario(scenario); }//this will allow the "arg: scenario" to be entered in string format or integer format
            const startpoint = endpoints[scenarioDecoded] + 1;//an accessor
            const endpoint = endpoints[scenarioDecoded + 1];
            const startpointofspecificPieceCountVsTime = endpointsofspecificPieceCountVsTime[scenarioDecoded] + 1;//an accessor
            const endpointofspecificPieceCountVsTime = endpointsofspecificPieceCountVsTime[scenarioDecoded + 1];
            //empty out the data arrays
            specificPointsVsTime.splice(0, specificPointsVsTime.length);
            specificPieceCountVsTime.splice(0, specificPieceCountVsTime.length);
            //for each point in the given range, push a point to the specificPointsVsTime array
            for (let i = startpoint; i < endpoint + 1; i++) { specificPointsVsTime.push(allPointsVsTime[i]); }
            for (let i = startpointofspecificPieceCountVsTime; i < endpointofspecificPieceCountVsTime + 1; i++) { specificPieceCountVsTime.push(allPieceCountVsTime[i]); }
            let string_copy = "";

            //delete the td's besides the first td
            let table = document.getElementById("table_id");
            for (let i = 0; i < table.rows.length; i++) {
                for (let j = table.rows[i].cells.length - 1; j > 0; j--) {
                    table.rows[i].deleteCell(j);
                }
            }

            for (let i in scenarioAction[scenarioDecoded]) {
                string_copy += scenarioAction[scenarioDecoded][i];
            }
            let loopcount = 0;
            while (string_copy.length > 0) {
                let i = string_copy.indexOf(";");
                
                const td = document.createElement("td");
                td.innerText = string_copy.substring(0, i);
                string_copy = string_copy.substring(i + 1);
                document.getElementById("tr2").appendChild(td);
                
                ++loopcount;
            }

            string_copy = "";
            for (let i in scenarioTimes[scenarioDecoded]) {
                string_copy += scenarioTimes[scenarioDecoded][i];
            }
            while (string_copy.length > 0) {
                const td0 = document.createElement("td");
                let i = string_copy.indexOf(";");
                td0.innerText = string_copy.substring(0, i);
                string_copy = string_copy.substring(i + 1);
                document.getElementById("tr0").appendChild(td0);

                const td1 = document.createElement("td");
                td1.innerText = 150 - td0.innerText;
                document.getElementById("tr1").appendChild(td1);
            }
        }
        function autonScorePiece(scenarioEncoded) {
            piecesScored[0] += holdingPiece[0];
            scenario.time -= scenario["Output (s)"];
            scenario.points += pointsForBestScorer[0] * holdingPiece[0];
            holdingPiece[0] = 0;
            addPlotData(scenarioEncoded, "scored speaker")
        }
        //do: addPlotData(scenarioEncoded,`scored ${ring} into ${target}")
        function collectPiece(scenarioEncoded, alreadyHoldingAndPositioned) {
            piecesScored[0] += holdingPiece[0];
            holdingPiece[0] = 0;
            scenario.time -= scenario["Output (s)"];
            if (!alreadyHoldingAndPositioned) {
                scenario.time -= scenario["Teleop Movement (s)"] * scenario["Stockpile Movement Fraction"] + scenario["Intake (s)"];
                ++scenario.piecesStockpiled;
                addPlotData(scenarioEncoded, "collected piece")
                return
            }
            addPlotData(scenarioEncoded, "scored piece")
        }
        //text for action must include "score" or "collect" if action increases piecesScored
        //"collect increases piecesScored b/c that would be too hard to track otherwise"
        var scenario = { points: 0, time: 150, z: 0 };
                    
            

        function addPlotData(scenarioEncoded, action) {
                game.allPointsVsTime.push({ x: 150 - scenario.time, y: scenario.points });
                scenarioAction[scenarioEncoded] = (scenarioAction[scenarioEncoded] ?? "") + action + ";"
                scenarioTimes[scenarioEncoded] = (scenarioTimes[scenarioEncoded] ?? "") + scenario.time + ";";
                if (action.includes("score") || action.includes("collect")) allPieceCountVsTime.push({ x: 150 - scenario.time, y: piecesScored[0] });
            }
            for(let i in iteratingArrays){
                iteratingArrays[i] = iteratingArrays[i][0]
                iteratingArrays[i].push=document.getElementById("ui"+i).value
            }
          
            numberOfScenarios = 1
            for (let i of iteratingArrays) { numberOfScenarios *= i.length - 1 }



function calculate(){}

//        function calculate(){
     
            const allPointsVsTime = game.allPointsVsTime=[], allPieceCountVsTime = game.allPieceCountVsTime
            const rnkValueVsScenario = game.rnkValueVsScenario, pieceCountVsScenario = game.pieceCountVsScenario, totalScoreVsScenario = game.totalScoreVsScenario, pieceCountVsTotalScore = game.pieceCountVsTotalScore, specificPointsVsTime = game.specificPointsVsTime, specificPieceCountVsTime = game.specificPieceCountVsTime
            const color = game.color;
            const scenarioAction = [], scenarioTimes = [], pointsClicked = [], zeroIndicesPointsClicked = [];
            var scenario = { points: 0, time: 150, z: 0 };
            let piecesScored = [], holdingPiece = [], links = [];

            //create a scenario tree
            for (let i = 0; i < numberOfScenarios; ++i) {
                const scenarioDecoded = decodeScenario(i)
                for (let j in iteratingArrays) {
                    scenario[iteratingArrays[j][0]] = iteratingArrays[j][Number(scenarioDecoded.charAt(j))+1]
                }
                //initialize the variables
                //last value set to 0 to keep track of what threshold the bot is up to
                piecesScored[0] = 0;
                holdingPiece[0] = 1;//start w/ holding one piece
                //holdingPiece[1]=1; //for a 2nd game piece
                scenario.time = 150; //seconds left in the game
                scenario.points = pointsForMobility;//will always get
                scenario.piecesStockpiled = 3;
                piecesScored[0] = 3;
                const trueBalancingTime = scenario["Balance (s)"] * (pointsForBalancing[0] > 0)

                //auton
                //if there's time to balance and score
                if (scenario.time - scenario["Output (s)"] - trueBalancingTime >= 135) {
                    //place pieces during auton
                    while (scenario.time - scenario["Output (s)"] - trueBalancingTime >= 135 && piecesScored[0] < autonPieceLimit) {
                        autonScorePiece(i);
                        if (scenario.time - scenario["Auton Movement (s)"] / 2 - scenario["Intake (s)"] >= 135) {//autonMovement is cut in half b/c the bot only travels to pick up game pices, not also back 
                            scenario.time -= scenario["Auton Movement (s)"] / 2 + scenario["Intake (s)"];
                            holdingPiece[0] += scenario["Grab Amount (on average)"];
                            if (piecesScored[0] + holdingPiece[0] > autonPieceLimit) {
                                //need to reduce the time to grab since grabbing less than the grabAmount
                                holdingPiece[0] = autonPieceLimit - piecesScored[0]
                            }//prevents holding more pieces than allowed given the autonPieceLimit and the pieces already scored: this is needed in a game where you can pick up more than one piece at a time
                            if (scenario.time - scenario["Auton Movement (s)"] / 2 - scenario["Output (s)"] - trueBalancingTime >= 135) {
                                scenario.time -= scenario["Auton Movement (s)"] / 2;
                            } else if (pointsForBalancing[0] > 0) {//balance if auton-balance is allowed
                                scenario.time = 135 + trueBalancingTime;
                                scenario.points += pointsForBalancing[0];
                                scenario.time -= scenario["Balance (s)"];
                                addPlotData(i, "balance");
                            } else { scenario.time = 135; }
                        }
                    }
                } else if (scenario.time - trueBalancingTime >= 135) {//balance if auton-balance is allowed
                    scenario.points += pointsForBalancing[0];
                    scenario.time -= scenario["Balance (s)"];
                    addPlotData(i, "balance");
                }
                //teleop
                scenario.time = 135;
                //scenarioAction[i] = (scenarioAction[i] ?? "") + "start of teleop;";
                //scenarioTimes[i] = (scenarioTimes[i] ?? "") + "135;";
                
                // if holding pieces at beginning of teleop
                if (holdingPiece[0] > 0) {
                    piecesScored[0] += holdingPiece[0];
                    holdingPiece[0] = 0;
                    scenario.time -= scenario["Output (s)"];
                    scenario.points += pointsForBestScorer[1]
                    
                    let linkscored = false
                    if(doLinksExist){
                        let sum=0

                        for(let j of linkProgression){
                            sum+=j
                            if(piecesScored[0]-sum==0){
                                scenario.points+=linkPoints[1]
                                linkscored=true
                            }
                        }
                    }
                    if(linkscored) addPlotData(i, "scored speaker & link")
                    else addPlotData(i, "scored speaker")
                }//this doesn't count the time it takes to go from the charge station into the grid, which is bad for games when the place where mobility points are awarded is far away from a goal
                //subtract time to go to centerfield
                scenario.time -= scenario["Teleop Movement (s)"] * (1 - scenario["Stockpile Movement Fraction"]) / 2;
                //subtract pickup & shoot and move/2 when gather a piece
                //when score a piece, subtract pickup & shoot besides the first piece which is already held and
                //when scoring pieces, time it will take is move/4 + pickup*(z-1)+place*z
                //time it will take to score z+1 pieces is move/2 + pickup*(z)+place*(z+1)+gather time
                //that equals move/2 + pickup*(z+1)+place*(z+1) + & shoot and move/2
                //either neglected move or place
                const traptime=scenario["Output (s)"] + scenario["Intake (s)"];
                const endBalanceTime = scenario["Teleop Movement (s)"] * (scenario["Stockpile Movement Fraction"])/2
                while (scenario.time - scenario["Teleop Movement (s)"] * (1 - scenario["Stockpile Movement Fraction"]) / 2 - scenario["Teleop Movement (s)"] * scenario["Stockpile Movement Fraction"] - (scenario.piecesStockpiled + 1) * (scenario["Output (s)"] + scenario["Intake (s)"]) - scenario["Balance (s)"] >= endBalanceTime + traptime) {//if we want the program to see how much slower we can be w/out worsening score changing the 0 in ">=0" to some other number is a start.
                    holdingPiece[0] += scenario["Grab Amount (on average)"];
                    collectPiece(i);
                }
                //endgame
                scenario.piecesStockpiled -= 1;

                //already holding one and need to move back
                scenario.time += scenario["Intake (s)"] - scenario["Teleop Movement (s)"] * (1 - scenario["Stockpile Movement Fraction"]) / 2;
                while (scenario.piecesStockpiled >= 3) {
                    for (let d = 0; d < 2; d++) {
                        scenario.points += 1;
                        scenario.time -= scenario["Intake (s)"] + scenario["Output (s)"];
                        scenario.piecesStockpiled -= 1;
                        addPlotData(i, "scored amp")
                    }
                    for (let d = 0; d < Math.floor(10 / (scenario["Intake (s)"] + scenario["Output (s)"])); d++) {
                        if (scenario.piecesStockpiled) {
                            scenario.points += 5;
                            scenario.time -= scenario["Intake (s)"] + scenario["Output (s)"];
                            --scenario.piecesStockpiled;
                            
                            let linkscored = false
                            if(doLinksExist){
                                let sum=0

                                for(let j of linkProgression){
                                    sum+=j
                                    if(piecesScored[0]-sum==0){
                                        scenario.points+=linkPoints[1]
                                        linkscored=true
                                    }
                                }
                            }
                            if(linkscored) addPlotData(i, "scored piece & link")
                            else addPlotData(i, "scored piece")
                            
                            addPlotData(i, "scored speaker")
                        }
                    }
                }
                while (scenario.piecesStockpiled > 0) {
                    --scenario.piecesStockpiled;
                    scenario.points += pointsForBestScorer[1];
                    scenario.time -= scenario["Intake (s)"] + scenario["Output (s)"];
                    addPlotData(i,"scored speaker")
                }
                scenario.points += pointsForBalancing[1];
                scenario.time -= scenario["Balance (s)"];
                addPlotData(i, "balance");
                scenario.time -= scenario["Output (s)"] + scenario["Intake (s)"];
                scenario.points += pointsForTrap[1];
                //since don't want to add to points scored, don't write "score"
                addPlotData(i,"scor_d trap")

                //push chart-values that have scenarios as a dimension
                if (piecesScored[0] >= piecesScoredForRnkPnt[0] && piecesScoredForRnkPnt[0] && piecesScored[1] >= piecesScoredForRnkPnt[1] && piecesScoredForRnkPnt[1]) {
                    rnkValueVsScenario.push({ x: i, y: 2 });
                    color.push("rgb(0,255,0)");
                } else if ((piecesScored[0] >= piecesScoredForRnkPnt[0] && piecesScoredForRnkPnt[0]) || (piecesScored[1] >= piecesScoredForRnkPnt[1] && piecesScoredForRnkPnt[1])) {
                    rnkValueVsScenario.push({ x: i, y: 1 });
                    color.push("rgb(255,255,0)");
                } else {
                    rnkValueVsScenario.push({ x: i, y: 0 });
                    color.push("rgb(255,0,0)");
                }
                totalScoreVsScenario.push({ x: i, y: scenario.points });
                pieceCountVsScenario.push({ x: i, y: piecesScored[0] });
                pieceCountVsTotalScore.push({ x: scenario.points, y: piecesScored[0], scenario: i })
            }

            //Figure out which scenario each set of scatter points belongs to by defining the endpoints of each scenaraio i.e. where one scenario stops and a new one starts.
            //To define where the endpoints will appear, loop through each value in the allPointsVsTime, which holds coordinate points for everytime the bot scores points for each scenario.
            //When the points-value (aka y-property) of one coordinate pair is less than the points of another coordinate pair, there must be a new scenario.
            const endpoints = [-1];//its -1 b/c it's the ending-point in a scenario where nothing happens: it was done like this so the next scenario starts w/ zero (-1+1=0). I added one b/c the endpoint of one scenario is 1 plus the startpoint of another scenario.
            for (let i = 0; i < allPointsVsTime.length - 1; ++i) {
                if (allPointsVsTime[i].x > allPointsVsTime[i + 1].x) { endpoints.push(i); }
            }
            endpoints.push(allPointsVsTime.length - 1);
            //do the same for the pieces scored-time chart
            const endpointsofspecificPieceCountVsTime = [-1];
            for (let i = 0; i < allPieceCountVsTime.length - 1; ++i) {
                if (allPieceCountVsTime[i].x > allPieceCountVsTime[i + 1].x) { endpointsofspecificPieceCountVsTime.push(i); }
            }
            endpointsofspecificPieceCountVsTime.push(allPieceCountVsTime.length - 1);

            //create data arrays that will be used for the all inclusive chart's tooltip
            const groupsofpoints = [], coordinatesofgroups = [];
            for (let i in pieceCountVsTotalScore) {
                const coordinates = pieceCountVsTotalScore[i].x + ";" + pieceCountVsTotalScore[i].y;
                //If the coordinates already exists in coordinatesofgroups, then just need to add these coordinates to the list. Otherwise, need to create the said array before pushing it into the array.
                if (coordinatesofgroups.includes(coordinates)) { groupsofpoints[coordinatesofgroups.indexOf(coordinates)].push(decodeScenario(i)); }
                else {
                    groupsofpoints.push([decodeScenario(i)]);
                    coordinatesofgroups.push(coordinates);
                }
            }
            const zeroindices = [], maxs = [], mins = [];
            for (let i of groupsofpoints) {
                zeroindices.push(i[0]);
                const min = [Infinity, Infinity, Infinity, Infinity, Infinity, Infinity, Infinity];
                const max = [-Infinity, -Infinity, -Infinity, -Infinity, -Infinity, -Infinity, -Infinity];

                for (let j of i) {
                    for (let scenarioattribute = 0; scenarioattribute < 6; ++scenarioattribute) {
                        if (j[scenarioattribute] < min[scenarioattribute]) {
                            min[scenarioattribute] = j[scenarioattribute];
                        }
                        if (j[scenarioattribute] > max[scenarioattribute]) {
                            max[scenarioattribute] = j[scenarioattribute];
                        }
                    }
                }
                maxs.push(max);
                mins.push(min);
            }
            updatedata(0);
        
        //load charts
 //       }
        window.addEventListener("load", function (e) { //only initialize chart once window loads completely to avoid context issues
            const scenariochart = new Chart("scenarioChart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: color,
                        data: pieceCountVsTotalScore
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'Pieces Scored/collected if stockpile - Total Score'
                    },
                    tooltips: {
                        bodyFontStyle: "bold",
                        footerFontStyle: "normal",
                        callbacks: {
                            label: function (tooltipItem, data) {
                                //if this is the first point in a group, than activate all the details for that group
                                const scenario = decodeScenario(tooltipItem.index);
                                if (zeroindices.includes(scenario)) {
                                    document.getElementById("tooltip").innerHTML = "";
                                    for (let i of groupsofpoints[zeroindices.indexOf(scenario)]) {
                                        const detail = document.createElement("details");
                                        document.getElementById("tooltip").appendChild(detail);
                                        let details = "<summary>" + i + "</summary>"
                                        for (let j in iteratingArrays) {
                                            details += iteratingArrays[j][0] + ": " + iteratingArrays[j][Number(i.charAt(j)) + 1] + "<br>"
                                        }
                                        detail.innerHTML = details
                                    }
                                }
                            },
                            //When points overlap, can only have one footer, but multiple labels.
                            footer: function (tooltipItems, data) {
                                return [
                                    "Total Score: " + pieceCountVsTotalScore[tooltipItems[0].index].x,
                                    "Pieces Scored: " + pieceCountVsTotalScore[tooltipItems[0].index].y,
                                    "Scenarios that exist: " + groupsofpoints[zeroindices.indexOf(decodeScenario(tooltipItems[0].index))].length
                                ];
                            }
                        }
                    },
                    onClick: function (evt) {
                        if (event.shiftKey) {
                            /*const element = scenariochart.getElementAtEvent(evt);
                            if (element.length > 0) {
                                const ind = element[0]._index;
                                if(!zeroIndicesPointsClicked.includes(ind)){//if not already included
                                    zeroIndicesPointsClicked.push(ind);
                                    //somehow maybe highlight it?
                                    
                                    pointsClicked.push([]);
                                    for(let i of groupsofpoints[ind]){
                                       pointsClicked[pointsClicked.length-1].push(i);
                                    }
                                    document.getElementById("shiftkey").innerHTML=pointsClicked;
                                }
                                else{
                                    pointsClicked.splice(zeroIndicesPointsClicked.indexOf(ind));
                                    zeroIndicesPointsClicked.splice(zeroIndicesPointsClicked.indexOf(ind));
                                    document.getElementById("shiftkey").innerHTML=pointsClicked;
                                }
                            }*/
                        }
                        else {
                            zeroIndicesPointsClicked.splice(0, this.length);
                            pointsClicked.splice(0, this.length);
                            document.getElementById("shiftkey").innerHTML = "";
                            const element = scenariochart.getElementAtEvent(evt);
                            if (element.length > 0) {
                                const ind = element[0]._index;
                                if (confirm('Do you want to see this scenario?')) {
                                    console.log(ind)
                                    updatedata(ind);
                                    psotchart.update();
                                    scoretimechart.update();
                                }
                            }
                        }

                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Total Score",
                            },
                            ticks: {
                                min: pieceCountVsTotalScore[pieceCountVsTotalScore.length - 1].x,
                                max: pieceCountVsTotalScore[0].x,
                            }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Pieces Scored/Collected if stockpile",
                            },
                            ticks: {
                                min: pieceCountVsTotalScore[pieceCountVsTotalScore.length - 1].y,
                                max: pieceCountVsTotalScore[0].y,
                            }
                        }],
                    }
                }
            });
            const rnkpntchart = new Chart("rnkpntChart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: color,
                        data: rnkValueVsScenario
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'RANK POINTS FROM PIECESSCORED - SCENARIO'
                    },
                    tooltips: {
                        bodyFontStyle: "bold",
                        footerFontStyle: "normal",
                        callbacks: {
                            label: function (tooltipItem, data) {
                                if (rnkValueVsScenario[tooltipItem.index].y === 0) { return "0"; }//there was a bug where if it was 0, then nothing it wouldn't show this
                                return rnkValueVsScenario[tooltipItem.index].y;
                            },
                            //color does not appear before the footer
                            footer: function (tooltipItems, data) {
                                return iteratingArrays.map(
                                    ([key, ...values], indexOfMap) =>
                                        key + ": " + values[decodeScenario(tooltipItems[0].index).charAt(indexOfMap)]
                                );
                            }
                        }
                    },
                    onClick: function (evt) {
                        var element = rnkpntchart.getElementAtEvent(evt);
                        if (element.length > 0) {
                            var ind = element[0]._index;
                            if (confirm('Do you want to see this scenario?')) {
                                updatedata(ind);
                                try {
                                    psotchart.update();
                                    scoretimechart.update();
                                    console.log("a")
                                } catch (error) {
                                    console.log(error);
                                }

                            }
                        }
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Scenarios Encoded",
                            },
                            ticks: { min: 0, max: numberOfScenarios - 1 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Rank Points From Links",
                            },
                            ticks: { min: 0, max: rnkValueVsScenario[0].y, stepSize: 1 }
                        }],
                    }
                }
            });
            const pschart = new Chart("psChart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: color,
                        data: totalScoreVsScenario
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'TOTAL SCORE - SCENARIO'
                    },
                    tooltips: {
                        bodyFontStyle: "bold",
                        footerFontStyle: "normal",
                        callbacks: {
                            label: function (tooltipItem, data) {
                                return totalScoreVsScenario[tooltipItem.index].y;
                            },
                            //color does not appear before the footer
                            footer: function (tooltipItems, data) {
                                return iteratingArrays.map(
                                    ([key, ...values], indexOfMap) =>
                                        key + ": " + values[decodeScenario(tooltipItems[0].index).charAt(indexOfMap)]

                                );
                            }
                        }
                    },
                    onClick: function (evt) {
                        var element = pschart.getElementAtEvent(evt);
                        if (element.length > 0) {
                            var ind = element[0]._index;
                            if (confirm('Do you want to see this scenario?')) {
                                updatedata(ind);
                                psotchart.update();
                                scoretimechart.update();
                            }
                        }
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Scenarios Encoded",
                            },
                            ticks: { min: 0, max: numberOfScenarios - 1 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Total Score",
                            },
                            ticks: { min: totalScoreVsScenario[totalScoreVsScenario.length - 1].y, max: totalScoreVsScenario[0].y }
                        }],
                    }
                }
            });
            const piecesschart = new Chart("piecesScoredchart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: color,
                        data: pieceCountVsScenario
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'PIECES SCORED - SCENARIO'
                    },
                    tooltips: {
                        bodyFontStyle: "bold",
                        footerFontStyle: "normal",
                        callbacks: {
                            label: function (tooltipItem, data) {
                                return pieceCountVsScenario[tooltipItem.index].y;
                            },
                            //color does not appear before the footer
                            footer: function (tooltipItems, data) {
                                return iteratingArrays.map(
                                    ([key, ...values], indexOfMap) =>
                                        key + ": " + values[decodeScenario(tooltipItems[0].index).charAt(indexOfMap)]
                                );
                            }

                        }
                    },
                    onClick: function (evt) {
                        var element = piecesschart.getElementAtEvent(evt);
                        if (element.length > 0) {
                            var ind = element[0]._index;
                            if (confirm('Do you want to see this scenario?')) {
                                updatedata(ind);
                                psotchart.update();
                                scoretimechart.update();
                            }
                        }
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Scenarios Encoded",
                            },
                            ticks: { min: 0, max: numberOfScenarios - 1 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Pieces Scored",
                            },
                            ticks: { min: pieceCountVsScenario[pieceCountVsScenario.length - 1].y, max: pieceCountVsScenario[0].y }
                        }],
                    }
                }
            });

            const psotchart = new Chart("psotchart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: "rgb(0,0,255)",
                        data: specificPieceCountVsTime
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'PIECES SCORED/collected if stockpile - TIME'
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Time",
                            },
                            ticks: { min: 0, max: 150 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Pieces Scored/collected if stockpile",
                            },
                            ticks: { min: 0, max: pieceCountVsScenario[0].y },
                        }],
                    }
                }
            });
            const scoretimechart = new Chart("myChart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: "rgb(0,0,255)",
                        data: specificPointsVsTime
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'SCORE - TIME'
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Time",
                            },
                            ticks: { min: 0, max: 150 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Score",
                            },
                            ticks: { min: 0, max: totalScoreVsScenario[0].y }
                        }],
                    }
                }
            });
        });
        
    </script>
</body>

</html>