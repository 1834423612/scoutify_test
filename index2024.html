<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Strategy Charts</title>
</head>
<style>
    body {
        overflow: hidden;
    }

    h1 {
        width: 100%;
        text-align: center;
    }

    div {
        display: inline-block
    }

    canvas {
        max-width: 40vw
    }

    ul {
        list-style: none;
    }

    details {
        border: 1px solid #aaa;
        border-radius: 4px;
        padding: 0.5em 0.5em 0;
    }

    summary {
        font-weight: bold;
        margin: -0.5em -0.5em 0;
        padding: 0.5em;
    }

    details[open] {
        padding: 0.5em;
    }

    details[open] summary {
        border-bottom: 1px solid #aaa;
        margin-bottom: 0.5em;
    }

    #split-view-container {
        display: flex;
        flex-direction: row;
        justify-content: center;
        width: 100vw;
        height: 80vh;
        overflow: hidden;
        overflow-x: hidden;
    }

    #split-view-divider {
        width: 2px;
        height: 100%;
        background-color: #aaa;
        margin-left: 2vw;
        margin-right: 2vw;
    }

    .split-view {
        width: 47%;
        height: 80%;
    }

    .scroller {
        width: 100%;
        height: 100%;
        overflow-y: scroll;
    }
</style>

<body>
    <h1>Charts</h1>


    <div id="split-view-container">
        <div class="split-view">
            <h3>Strategy Comparison</h1>
                <details>
                    <summary>Key:</summary>
                    <ul>
                        <pre>
                        <li><mark style="background-color:rgb(0,255,0);">  </mark> : 2 RNKPNT (not tracking this every year)</li>
                        <li><mark style="background-color:rgb(255, 255, 0);">  </mark> : 1 RNKPNT</li>
                        <li><mark style="background-color:rgb(255,0,0);">  </mark> : 0 RNKPNT</li>
                    </pre>
                    </ul>
                </details>
                <div class="scroller">
                    <div style="display:block;">
                        <canvas id="psChart"></canvas>
                        <canvas id="piecesscoredchart"></canvas> <!--Total Score-Scenario Chart-->
                        <p>Note that the color indicator for this graph is inaccurate b/c the points overlap. This year
                            it's ok b/c
                            the rnkpnt is given to for getting a y-value greater than a certain number</p>
                        <canvas id="scenarioChart"></canvas> <!--Pieces vs Total Score-->
                        <canvas id="rnkpntChart"></canvas> <!--Ranking points vs Scenario id-->
                    </div>
                </div>
        </div>
        <div id="split-view-divider"></div>
        <div class="split-view">
            <h3>Selected Scenario</h3>
            <div class="scroller">
                <p id="tooltip"></p>
                <div style="display:block">
                    <canvas id="psotchart"></canvas>
                    <p>Note: always balances at 15s but not necessarily at the end</p>
                    <canvas id="myChart"></canvas>
                </div>
            </div>
        </div>
    </div>



    <script type="module" src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.4/Chart.js"></script>
    <script type="text/javascript" src="http://code.jquery.com/jquery.min.js"></script>
    <script>
        //qual version w/ traps, balance, atain co-op, and includes amplifications

        //to get rnkpoint for 10 onstage points, must get one note in trap and balance
        //add logic to score in the amp as soon as teleop starts once
        //need to add in trapping time
        //need to add in seperate times for the different scoring locations

        //when to go for amp and when not to?
        //If one piece can be scored in the 10 seconds (automatic b/c you only have to press the button when you're ready), the robot will be able to score 2 amps and a speaker in the time it takes to score three speakers (assumption w/out proof). This turns out to be seven points versus six points, and could be more b/c the alliance members also have to score. This means it is worth it to score the two amps and then the speaker assuming there is enough time

        //may need to change the portion the charts show
        const dolinkshappeninthisgame = false;
        const linkthresholdprogression = [];//leave this empty unless the links[1] is changing (links[1] is in the for-loop and represents how many pieces makes a link) like in the game steamworks
        //for the steamship game, const linkthresholdprogression=[1,2,3,4,5];
        //for any of the following time arrays and the grabamount array, the first index must have the smallest value, and the last index must have the largest value
        const balancingtime = [3, 5, 8, 12, 15];//trapping will be added if pointsforbalancing==8
        const pointsforbalancing = [0,3];//auton and teleop
        const trappingTime = [3, 5, 7, 9];
        const placetime = [2, 4];
        const pointsforbestscorer = [5, 2];//speaker
        const limitforbestscorer = Infinity;
        const pointsforokscorer = [2, 1];//amp
        const pickuptime = [2, 4];
        const autonmovepartofcycle = [4, 6];//of closer pieces (not the ones on the centerline since the robot won't be that fast anyways)
        const movepartofcycle = [7, 9, 11];//if the game is pick & place and the goals take different times to travel to, estimate the average travel time
        const autonPieceLimit = 8;
        const pointsformobility = 2;
        const grabamount = [1];//for games where you can grab more than one piece, this is the estimated average pieces grabbed. this must be a whole number
        const holdPieceLimit = 1;
        const piecesscoredforrnkpnt = [15, 0];
        //for charts
        const scenariospoints = [];//looks like this: [{x:time,y:points},...] & this contains multiple coordinate pairs for each scenario
        const piecesscoredovertime = [];//like the scenariospoints array except the y-values track the pieces scored instead
        const rnkValues = [];//looks like this: [{x:1stScenarioInTheScenarioTree,y: #ofRnkPnts from links},...{x:lastScenarioInTheScenarioTree,y: #ofRnkPnts from links}] 
        const piecesoverscenarios = [];//like rnkValues except the y-properties show pieces scored
        const totalscores = [];//like rnkValues except the y-properties show the totalscores
        const allinclusivescenariodata = [];//like rnkValues except the y-properties are pieces scored and the x-properties show the totalscores
        const color = [];//looks like this: ["rgb(color for 1stScenarioInTheScenarioTree)",..."rgb(color for lastScenarioInTheScenarioTree)"] 
        const xyValues = [];//this is for a single scenario & looks like this: [{x:score,y:time},...]
        const psotValues = [];//looks like xyValues except x-property is pieces scored

        //make a scenario to be represented by two data types, a string and integer
        //this needs to be done b/c the chart can't use a string for numbers on an axis & the human has no idea what the number is
        //define some scenario related variables
        const allthelengthsbesidesbalance = placetime.length * pickuptime.length * autonmovepartofcycle.length * movepartofcycle.length * grabamount.length;
        const allthelengthsbesidesbalanceandplace = pickuptime.length * autonmovepartofcycle.length * movepartofcycle.length * grabamount.length;
        const allthelengthsbesidesbalanceandplaceandpickup = autonmovepartofcycle.length * movepartofcycle.length * grabamount.length;
        const lengthsofmovepartofcycleandgrabamount = movepartofcycle.length * grabamount.length;
        //turn a string that represents the indices in the scenario tree below into a number
        const encodescenario = (a) =>
            a.charAt(0) * allthelengthsbesidesbalance +
            a.charAt(1) * allthelengthsbesidesbalanceandplace +
            a.charAt(2) * allthelengthsbesidesbalanceandplaceandpickup +
            a.charAt(3) * lengthsofmovepartofcycleandgrabamount +
            a.charAt(4) * grabamount.length +
            a.charAt(5) * 1//the multiplication by one switches the type from string to number so that the a.charAt(4) is added instead of concatenated
            ;
        //the following function undoes the encodescenario function by converting a scenario from the number format into the string format
        const decodescenario = (a) =>
            "" +
            Math.floor(a / allthelengthsbesidesbalance) +
            Math.floor(a % allthelengthsbesidesbalance / allthelengthsbesidesbalanceandplace) +
            Math.floor(a % allthelengthsbesidesbalance % allthelengthsbesidesbalanceandplace / allthelengthsbesidesbalanceandplaceandpickup) +
            Math.floor(a % allthelengthsbesidesbalance % allthelengthsbesidesbalanceandplace % allthelengthsbesidesbalanceandplaceandpickup / lengthsofmovepartofcycleandgrabamount) +
            Math.floor(a % allthelengthsbesidesbalance % allthelengthsbesidesbalanceandplace % allthelengthsbesidesbalanceandplaceandpickup % lengthsofmovepartofcycleandgrabamount / grabamount.length) +
            a % allthelengthsbesidesbalance % allthelengthsbesidesbalanceandplace % allthelengthsbesidesbalanceandplaceandpickup % lengthsofmovepartofcycleandgrabamount % grabamount.length
            ;


        //create a scenario tree, but start by defining variables to use during the iterations
        const scenario = { points: 0, time: 150, piecesscoredinamp:0 };
        let piecesscored = [], holdingpiece = [], links = [];
        for (let i in balancingtime) {
            for (let j in placetime) {
                for (let k in pickuptime) {
                    for (let l in autonmovepartofcycle) {
                        for (let m in movepartofcycle) {
                            for (let n in grabamount) {
                                //this loops through each scenario where the scenario is defined in string format as (""+i+j+k+l+m+n) 
                                //initialize the variables
                                links = [dolinkshappeninthisgame, 3, 5, 5, 0];//first value is to see if links exist, the second value is how many pieces one needs for a link, and the 3rd value is the points for getting a link during auton and the 4th value is the points during teleop; for the steamship game, the gears should should be the bestscoring method that makes 0 points, but this array will be [true,1,60,40], and whenever we get the threshold the game, we will have to update the second value
                                //links has a fith value set to 0 to keep track of what threshold the bot is up to
                                piecesscored[0] = 0;
                                holdingpiece[0] = 1;//start w/ holding one piece
                                //holdingpiece[0]=1;//for a 2nd game piece
                                scenario.time = 150; //seconds left in the game
                                scenario.points = pointsformobility;//will always strive to make a robot that can get the mobility points
                                scenario.piecesscoredinamp = -1;//b/c of coop
                                //auton
                                //if(!startpreloaded){time-pickuptime[k]}
                                //if(!startneargoal){time-autonmovepartofcycle[l]} this is unimplemented yet

                                //if there's time to balance and score...
                                if (scenario.time - placetime[j] - balancingtime[i] * (pointsforbalancing[0] > 0) >= 135) {
                                    //place pieces during auton
                                    while (scenario.time - placetime[j] - balancingtime[i] * (pointsforbalancing[0] > 0) >= 135 && piecesscored[0] < autonPieceLimit) {
                                        scorepiece(0, j, k, m);
                                        if (scenario.time - autonmovepartofcycle[l] / 2 - pickuptime[k] >= 135) {//the autonmovepartofcycle[l] is divided by two b/c the bot only travels to pick up game pices, not also back 
                                            scenario.time -= autonmovepartofcycle[l] / 2 + pickuptime[k];
                                            holdingpiece[0] += grabamount[n];
                                            if (piecesscored[0] + holdingpiece[0] > autonPieceLimit) { holdingpiece[0] = autonPieceLimit - piecesscored[0] }//prevents holding more pieces than allowed given the autonPieceLimit and the pieces already scored: this is needed in a game where you can pick up more than one piece at a time
                                            if (scenario.time - autonmovepartofcycle[l] / 2 - placetime[j] - balancingtime[i] * (pointsforbalancing[0] > 0) >= 135) { scenario.time -= autonmovepartofcycle[l] / 2; }
                                            else if (pointsforbalancing[0] > 0) {//balance if auton-balance is allowed
                                                scenario.time = 135 + balancingtime[i] * (pointsforbalancing[0] > 0);
                                                balance(0, i);
                                            }
                                            else { scenario.time = 135; }
                                        }
                                    }
                                }
                                else if (pointsforbalancing[0] > 0) { balance(0, i); }//balance if auton-balance is allowed
                                //teleop
                                scenario.time = 135;
                                // if holding pieces at beginning of teleop
                                if (holdingpiece[0] > 0) { scorepiece(1, j, k, m, 1); }//this doesn't count the time it takes to go from the charge station into the grid, which is bad for games when the place where mobility points are awarded is far away from a goal
                                //score high and mid
                                while (scenario.time - pickuptime[k] - movepartofcycle[m] - placetime[j] - balancingtime[i] * (pointsforbalancing[1] > 0) >= 0) {//if we want the program to see how much slower we can be w/out worsening score changing the 0 in ">=0" to some other number is a start.
                                    holdingpiece[0] += grabamount[n];
                                    scorepiece(1, j, k, m);
                                }
                                //endgame
                                if (pointsforbalancing[1] > 0) { balance(1, i); }
                                //push chart values that have scenarios as a dimension
                                const x = encodescenario('' + i + j + k + l + m + n);
                                if (piecesscored[0] >= piecesscoredforrnkpnt[0] && piecesscoredforrnkpnt[0] && piecesscored[1] >= piecesscoredforrnkpnt[1] && piecesscoredforrnkpnt[1]) {
                                    rnkValues.push({ x: x, y: 2 });
                                    color.push("rgb(0,255,0)");
                                }
                                else if ((piecesscored[0] >= piecesscoredforrnkpnt[0] && piecesscoredforrnkpnt[0]) || (piecesscored[1] >= piecesscoredforrnkpnt[1] && piecesscoredforrnkpnt[1])) {
                                    rnkValues.push({ x: x, y: 1 });
                                    color.push("rgb(255,255,0)");
                                }
                                else {
                                    rnkValues.push({ x: x, y: 0 });
                                    color.push("rgb(255,0,0)");
                                }
                                totalscores.push({ x: x, y: scenario.points });
                                piecesoverscenarios.push({ x: x, y: piecesscored[0] });
                                allinclusivescenariodata.push({ x: scenario.points, y: piecesscored[0], scenario: x })
                            }
                        }
                    }
                }
            }
        }


        //Figure out which scenario each set of scatter points belongs to by defining the endpoints of each scenaraio i.e. where one scenario stops and a new one starts.
        //To define where the endpoints will appear, loop through each value in the scenariospoints, which holds coordinate points for everytime the bot scores points for each scenario.
        //When the points-value (aka y-property) of one coordinate pair is less than the points of another coordinate pair, there must be a new scenario.
        const endpoints = [-1];//its -1 b/c it's the ending-point in a scenario where nothing happens: it was done like this so the next scenario starts w/ zero (-1+1=0). I added one b/c the endpoint of one scenario is 1 plus the startpoint of another scenario.
        for (let i = 0; i < scenariospoints.length - 1; i++) {
            if (scenariospoints[i].x > scenariospoints[i + 1].x) { endpoints.push(i); }
        }
        endpoints.push(scenariospoints.length);
        //do the same for the pieces scored-time chart
        const endpointsofpsotValues = [-1];
        for (let i = 0; i < piecesscoredovertime.length - 1; i++) {
            if (piecesscoredovertime[i].x > piecesscoredovertime[i + 1].x) { endpointsofpsotValues.push(i); }
        }
        endpointsofpsotValues.push(piecesscoredovertime.length);


        //create data arrays that will be used for the all inclusive chart's tooltip
        const groupsofpoints = [];
        const coordinatesofgroups = [];
        for (let i in allinclusivescenariodata) {
            const coordinates = allinclusivescenariodata[i].x + ";" + allinclusivescenariodata[i].y;
            //If the coordinates already exists in coordinatesofgroups, then just need to add these coordinates to the list. Otherwise, need to create the said array before pushing it into the array.
            if (coordinatesofgroups.includes(coordinates)) { groupsofpoints[coordinatesofgroups.indexOf(coordinates)].push(decodescenario(i)); }
            else {
                groupsofpoints.push([decodescenario(i)]);
                coordinatesofgroups.push(coordinates);
            }
        }
        const zeroindices = [];
        for (let i of groupsofpoints) { zeroindices.push(i[0]); }


        //load charts
        updatedata(0);
        window.addEventListener("load", function (event) { //only initialize chart once window loads completely to avoid context issues
            const scenariochart = new Chart("scenarioChart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: color,
                        data: allinclusivescenariodata
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'Pieces Scored - Total Score'
                    },
                    tooltips: {
                        bodyFontStyle: "bold",
                        footerFontStyle: "normal",
                        callbacks: {
                            label: function (tooltipItem, data) {
                                //if this is the first point in a group, than activate all the details for that group
                                const scenario = decodescenario(tooltipItem.index);
                                if (zeroindices.includes(scenario)) {
                                    document.getElementById("tooltip").innerHTML = "";
                                    for (let i of groupsofpoints[zeroindices.indexOf(scenario)]) {
                                        const detail = document.createElement("details");
                                        document.getElementById("tooltip").appendChild(detail);
                                        detail.innerHTML = "<summary>" + i + "</summary>" +
                                            "Balance (s): " + balancingtime[i.charAt(0)] + "<br>" +
                                            "Place (s): " + placetime[i.charAt(1)] + "<br>" +
                                            "Pickup (s): " + pickuptime[i.charAt(2)] + "<br>" +
                                            "Autonmovepartofcycle (s): " + autonmovepartofcycle[i.charAt(3)] + "<br>" +
                                            "Movepartofcycle (s): " + movepartofcycle[i.charAt(4)] + "<br>" +
                                            "Grabamount (pieces on average): " + grabamount[i.charAt(5)]
                                            ;
                                    }
                                }
                            },
                            //When points overlap, can only have one footer, but multiple labels.
                            footer: function (tooltipItems, data) {
                                return [
                                    "Total Score: " + allinclusivescenariodata[tooltipItems[0].index].x,
                                    "Pieces Scored: " + allinclusivescenariodata[tooltipItems[0].index].y
                                ];
                            }
                        }
                    },
                    onClick: function (evt) {
                        var element = scenariochart.getElementAtEvent(evt);
                        if (element.length > 0) {
                            var ind = element[0]._index;
                            if (confirm('Do you want to see this scenario?')) {
                                updatedata(ind);
                                psotchart.update();
                                scoretimechart.update();
                            }
                        }
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Total Score",
                            },
                            ticks: {
                                min: allinclusivescenariodata[allinclusivescenariodata.length - 1].x,
                                max: allinclusivescenariodata[0].x,
                            }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Pieces Scored",
                            },
                            ticks: {
                                min: allinclusivescenariodata[allinclusivescenariodata.length - 1].y,
                                max: allinclusivescenariodata[0].y,
                            }
                        }],
                    }
                }
            });
            const rnkpntchart = new Chart("rnkpntChart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: color,
                        data: rnkValues
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'RANK POINTS FROM LINKS - SCENARIO'
                    },
                    tooltips: {
                        bodyFontStyle: "bold",
                        footerFontStyle: "normal",
                        callbacks: {
                            label: function (tooltipItem, data) {
                                if (rnkValues[tooltipItem.index].y === 0) { return "0"; }//there was a bug where if it was 0, then nothing it wouldn't show this
                                return rnkValues[tooltipItem.index].y;
                            },
                            //color does not appear before the footer
                            footer: function (tooltipItems, data) {
                                return [
                                    "Balance (s): " + balancingtime[decodescenario(tooltipItems[0].index).charAt(0)],
                                    "Place (s): " + placetime[decodescenario(tooltipItems[0].index).charAt(1)],
                                    "Pickup (s): " + pickuptime[decodescenario(tooltipItems[0].index).charAt(2)],
                                    "Autonmovepartofcycle (s): " + autonmovepartofcycle[decodescenario(tooltipItems[0].index).charAt(3)],
                                    "Movepartofcycle (s): " + movepartofcycle[decodescenario(tooltipItems[0].index).charAt(4)],
                                    "Grabamount (pieces on average): " + grabamount[decodescenario(tooltipItems[0].index).charAt(5)]
                                ];
                            }
                        }
                    },
                    onClick: function (evt) {
                        var element = rnkpntchart.getElementAtEvent(evt);
                        if (element.length > 0) {
                            var ind = element[0]._index;
                            if (confirm('Do you want to see this scenario?')) {
                                updatedata(ind);
                                psotchart.update();
                                scoretimechart.update();
                            }
                        }
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Scenarios Encoded",
                            },
                            ticks: { min: 0, max: balancingtime.length * allthelengthsbesidesbalance - 1 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Rank Points From Links",
                            },
                            ticks: { min: 0, max: rnkValues[0].y, stepSize: 1 }
                        }],
                    }
                }
            });
            const pschart = new Chart("psChart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: color,
                        data: totalscores
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'TOTAL SCORE - SCENARIO'
                    },
                    tooltips: {
                        bodyFontStyle: "bold",
                        footerFontStyle: "normal",
                        callbacks: {
                            label: function (tooltipItem, data) {
                                return totalscores[tooltipItem.index].y;
                            },
                            //color does not appear before the footer
                            footer: function (tooltipItems, data) {
                                return [
                                    "Balance (s): " + balancingtime[decodescenario(tooltipItems[0].index).charAt(0)],
                                    "Place (s): " + placetime[decodescenario(tooltipItems[0].index).charAt(1)],
                                    "Pickup (s): " + pickuptime[decodescenario(tooltipItems[0].index).charAt(2)],
                                    "Autonmovepartofcycle (s): " + autonmovepartofcycle[decodescenario(tooltipItems[0].index).charAt(3)],
                                    "Movepartofcycle (s): " + movepartofcycle[decodescenario(tooltipItems[0].index).charAt(4)],
                                    "Grabamount (pieces on average): " + grabamount[decodescenario(tooltipItems[0].index).charAt(5)]
                                ];
                            }

                        }
                    },
                    onClick: function (evt) {
                        var element = pschart.getElementAtEvent(evt);
                        if (element.length > 0) {
                            var ind = element[0]._index;
                            if (confirm('Do you want to see this scenario?')) {
                                updatedata(ind);
                                psotchart.update();
                                scoretimechart.update();
                            }
                        }
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Scenarios Encoded",
                            },
                            ticks: { min: 0, max: balancingtime.length * allthelengthsbesidesbalance - 1 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Total Score",
                            },
                            ticks: { min: totalscores[totalscores.length - 1].y, max: totalscores[0].y }
                        }],
                    }
                }
            });
            const piecesschart = new Chart("piecesscoredchart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: color,
                        data: piecesoverscenarios
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'PIECES SCORED - SCENARIO'
                    },
                    tooltips: {
                        bodyFontStyle: "bold",
                        footerFontStyle: "normal",
                        callbacks: {
                            label: function (tooltipItem, data) {
                                return piecesoverscenarios[tooltipItem.index].y;
                            },
                            //color does not appear before the footer
                            footer: function (tooltipItems, data) {
                                return [
                                    "Balance (s): " + balancingtime[decodescenario(tooltipItems[0].index).charAt(0)],
                                    "Place (s): " + placetime[decodescenario(tooltipItems[0].index).charAt(1)],
                                    "Pickup (s): " + pickuptime[decodescenario(tooltipItems[0].index).charAt(2)],
                                    "Autonmovepartofcycle (s): " + autonmovepartofcycle[decodescenario(tooltipItems[0].index).charAt(3)],
                                    "Movepartofcycle (s): " + movepartofcycle[decodescenario(tooltipItems[0].index).charAt(4)],
                                    "Grabamount (pieces on average): " + grabamount[decodescenario(tooltipItems[0].index).charAt(5)]
                                ];
                            }

                        }
                    },
                    onClick: function (evt) {
                        var element = piecesschart.getElementAtEvent(evt);
                        if (element.length > 0) {
                            var ind = element[0]._index;
                            if (confirm('Do you want to see this scenario?')) {
                                updatedata(ind);
                                psotchart.update();
                                scoretimechart.update();
                            }
                        }
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Scenarios Encoded",
                            },
                            ticks: { min: 0, max: balancingtime.length * allthelengthsbesidesbalance - 1 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Pieces Scored",
                            },
                            ticks: { min: piecesoverscenarios[piecesoverscenarios.length - 1].y, max: piecesoverscenarios[0].y }
                        }],
                    }
                }
            });

            const psotchart = new Chart("psotchart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: "rgb(0,0,255)",
                        data: psotValues
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'PIECES SCORED - TIME'
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Time",
                            },
                            ticks: { min: 0, max: 150 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Pieces Scored",
                            },
                            ticks: { min: 0, max: piecesoverscenarios[0].y },
                        }],
                    }
                }
            });
            const scoretimechart = new Chart("myChart", {
                type: "scatter",
                data: {
                    datasets: [{
                        pointRadius: 4,
                        pointBackgroundColor: "rgb(0,0,255)",
                        data: xyValues
                    }]
                },
                options: {
                    title: {
                        display: true,
                        text: 'SCORE - TIME'
                    },
                    legend: { display: false },
                    scales: {
                        xAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Time",
                            },
                            ticks: { min: 0, max: 150 }
                        }],
                        yAxes: [{
                            scaleLabel: {
                                display: true,
                                labelString: "Score",
                            },
                            ticks: { min: 0, max: totalscores[0].y }
                        }],
                    }
                }
            });
        });
        function updatedata(scenario) {
            let scenarioencoded = scenario;
            if (typeof (scenario) === "string") { scenarioencoded = encodescenario(scenario); }//this will allow the "arg: scenario" to be entered in string format or integer format
            const startpoint = endpoints[scenarioencoded] + 1;//an accessor
            const endpoint = endpoints[scenarioencoded + 1];
            const startpointofpsotValues = endpointsofpsotValues[scenarioencoded] + 1;//an accessor
            const endpointofpsotValues = endpointsofpsotValues[scenarioencoded + 1];
            //empty out the data arrays
            xyValues.splice(0, xyValues.length);
            psotValues.splice(0, psotValues.length);
            //for each point in the given range, push a point to the xyValues array
            for (let i = startpoint; i < endpoint + 1; i++) { xyValues.push(scenariospoints[i]); }
            for (let i = startpointofpsotValues; i < endpointofpsotValues + 1; i++) { psotValues.push(piecesscoredovertime[i]); }
        }
        function checkforlinks(ifauton0ifteleop1) {
            if (links[0] && piecesscored[0] % links[1] === 0) {
                scenario.points += links[2 + ifauton0ifteleop1];
                if (linkthresholdprogression.length > 0) {
                    ++links[4];
                    links[1] = linkthresholdprogression[links[4]];
                }
            }
        }
        function scorepiece(ifauton0ifteleop1, j, k, m, holdingpiecesatbeginningofteleop) {
            piecesscored[0] += holdingpiece[0];
            if (holdingpiecesatbeginningofteleop === 1 || ifauton0ifteleop1 === 0) { scenario.time -= placetime[j]; }
            else { scenario.time -= placetime[j] + movepartofcycle[m] + pickuptime[k]; }
            if (piecesscored[0] <= limitforbestscorer) { scenario.points += pointsforbestscorer[ifauton0ifteleop1] * holdingpiece[0]; }
            else { scenario.points += pointsforokscorer[ifauton0ifteleop1] * holdingpiece[0]; }
            holdingpiece[0] = 0;
            checkforlinks(ifauton0ifteleop1);
            scenariospoints.push({ x: 150 - scenario.time, y: scenario.points });
            piecesscoredovertime.push({ x: 150 - scenario.time, y: piecesscored[0] });
        }
        function balance(ifauton0ifteleop1, i) {
            scenario.points += pointsforbalancing[ifauton0ifteleop1];
            scenario.time -= balancingtime[i];
            scenariospoints.push({ x: 150 - scenario.time, y: scenario.points });
        }
    </script>

</body>

</html>
